/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.hathora.cloud_sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.hathora.cloud_sdk.utils.Utils;
import java.lang.Double;
import java.lang.Override;
import java.lang.String;


public class NodeShapeV2 {

    @JsonProperty("familyId")
    private NodeFamilyId familyId;

    /**
     * A human readable name for this node's family.
     */
    @JsonProperty("familyName")
    private String familyName;

    /**
     * The minimum number of CPUs that will be in any node with this shape.
     * Note: this number may change as new providers are added.
     */
    @JsonProperty("minCPU")
    private double minCPU;

    /**
     * The minimum number of GPUs that will be in any node with this shape.
     * Note: this number may change as new providers are added.
     */
    @JsonProperty("minGPU")
    private double minGPU;

    /**
     * The minimum MB of memory that will be in any node with this shape.
     * Note: this number may change as new providers are added.
     */
    @JsonProperty("minMemoryMB")
    private double minMemoryMB;

    /**
     * A human readable name for this node shape.
     */
    @JsonProperty("name")
    private String name;


    @JsonProperty("nodeShapeId")
    private NodeShapeId nodeShapeId;

    @JsonCreator
    public NodeShapeV2(
            @JsonProperty("familyId") NodeFamilyId familyId,
            @JsonProperty("familyName") String familyName,
            @JsonProperty("minCPU") double minCPU,
            @JsonProperty("minGPU") double minGPU,
            @JsonProperty("minMemoryMB") double minMemoryMB,
            @JsonProperty("name") String name,
            @JsonProperty("nodeShapeId") NodeShapeId nodeShapeId) {
        Utils.checkNotNull(familyId, "familyId");
        Utils.checkNotNull(familyName, "familyName");
        Utils.checkNotNull(minCPU, "minCPU");
        Utils.checkNotNull(minGPU, "minGPU");
        Utils.checkNotNull(minMemoryMB, "minMemoryMB");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(nodeShapeId, "nodeShapeId");
        this.familyId = familyId;
        this.familyName = familyName;
        this.minCPU = minCPU;
        this.minGPU = minGPU;
        this.minMemoryMB = minMemoryMB;
        this.name = name;
        this.nodeShapeId = nodeShapeId;
    }

    @JsonIgnore
    public NodeFamilyId familyId() {
        return familyId;
    }

    /**
     * A human readable name for this node's family.
     */
    @JsonIgnore
    public String familyName() {
        return familyName;
    }

    /**
     * The minimum number of CPUs that will be in any node with this shape.
     * Note: this number may change as new providers are added.
     */
    @JsonIgnore
    public double minCPU() {
        return minCPU;
    }

    /**
     * The minimum number of GPUs that will be in any node with this shape.
     * Note: this number may change as new providers are added.
     */
    @JsonIgnore
    public double minGPU() {
        return minGPU;
    }

    /**
     * The minimum MB of memory that will be in any node with this shape.
     * Note: this number may change as new providers are added.
     */
    @JsonIgnore
    public double minMemoryMB() {
        return minMemoryMB;
    }

    /**
     * A human readable name for this node shape.
     */
    @JsonIgnore
    public String name() {
        return name;
    }

    @JsonIgnore
    public NodeShapeId nodeShapeId() {
        return nodeShapeId;
    }

    public static Builder builder() {
        return new Builder();
    }


    public NodeShapeV2 withFamilyId(NodeFamilyId familyId) {
        Utils.checkNotNull(familyId, "familyId");
        this.familyId = familyId;
        return this;
    }

    /**
     * A human readable name for this node's family.
     */
    public NodeShapeV2 withFamilyName(String familyName) {
        Utils.checkNotNull(familyName, "familyName");
        this.familyName = familyName;
        return this;
    }

    /**
     * The minimum number of CPUs that will be in any node with this shape.
     * Note: this number may change as new providers are added.
     */
    public NodeShapeV2 withMinCPU(double minCPU) {
        Utils.checkNotNull(minCPU, "minCPU");
        this.minCPU = minCPU;
        return this;
    }

    /**
     * The minimum number of GPUs that will be in any node with this shape.
     * Note: this number may change as new providers are added.
     */
    public NodeShapeV2 withMinGPU(double minGPU) {
        Utils.checkNotNull(minGPU, "minGPU");
        this.minGPU = minGPU;
        return this;
    }

    /**
     * The minimum MB of memory that will be in any node with this shape.
     * Note: this number may change as new providers are added.
     */
    public NodeShapeV2 withMinMemoryMB(double minMemoryMB) {
        Utils.checkNotNull(minMemoryMB, "minMemoryMB");
        this.minMemoryMB = minMemoryMB;
        return this;
    }

    /**
     * A human readable name for this node shape.
     */
    public NodeShapeV2 withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    public NodeShapeV2 withNodeShapeId(NodeShapeId nodeShapeId) {
        Utils.checkNotNull(nodeShapeId, "nodeShapeId");
        this.nodeShapeId = nodeShapeId;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        NodeShapeV2 other = (NodeShapeV2) o;
        return 
            Utils.enhancedDeepEquals(this.familyId, other.familyId) &&
            Utils.enhancedDeepEquals(this.familyName, other.familyName) &&
            Utils.enhancedDeepEquals(this.minCPU, other.minCPU) &&
            Utils.enhancedDeepEquals(this.minGPU, other.minGPU) &&
            Utils.enhancedDeepEquals(this.minMemoryMB, other.minMemoryMB) &&
            Utils.enhancedDeepEquals(this.name, other.name) &&
            Utils.enhancedDeepEquals(this.nodeShapeId, other.nodeShapeId);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            familyId, familyName, minCPU,
            minGPU, minMemoryMB, name,
            nodeShapeId);
    }
    
    @Override
    public String toString() {
        return Utils.toString(NodeShapeV2.class,
                "familyId", familyId,
                "familyName", familyName,
                "minCPU", minCPU,
                "minGPU", minGPU,
                "minMemoryMB", minMemoryMB,
                "name", name,
                "nodeShapeId", nodeShapeId);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private NodeFamilyId familyId;

        private String familyName;

        private Double minCPU;

        private Double minGPU;

        private Double minMemoryMB;

        private String name;

        private NodeShapeId nodeShapeId;

        private Builder() {
          // force use of static builder() method
        }


        public Builder familyId(NodeFamilyId familyId) {
            Utils.checkNotNull(familyId, "familyId");
            this.familyId = familyId;
            return this;
        }


        /**
         * A human readable name for this node's family.
         */
        public Builder familyName(String familyName) {
            Utils.checkNotNull(familyName, "familyName");
            this.familyName = familyName;
            return this;
        }


        /**
         * The minimum number of CPUs that will be in any node with this shape.
         * Note: this number may change as new providers are added.
         */
        public Builder minCPU(double minCPU) {
            Utils.checkNotNull(minCPU, "minCPU");
            this.minCPU = minCPU;
            return this;
        }


        /**
         * The minimum number of GPUs that will be in any node with this shape.
         * Note: this number may change as new providers are added.
         */
        public Builder minGPU(double minGPU) {
            Utils.checkNotNull(minGPU, "minGPU");
            this.minGPU = minGPU;
            return this;
        }


        /**
         * The minimum MB of memory that will be in any node with this shape.
         * Note: this number may change as new providers are added.
         */
        public Builder minMemoryMB(double minMemoryMB) {
            Utils.checkNotNull(minMemoryMB, "minMemoryMB");
            this.minMemoryMB = minMemoryMB;
            return this;
        }


        /**
         * A human readable name for this node shape.
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }


        public Builder nodeShapeId(NodeShapeId nodeShapeId) {
            Utils.checkNotNull(nodeShapeId, "nodeShapeId");
            this.nodeShapeId = nodeShapeId;
            return this;
        }

        public NodeShapeV2 build() {

            return new NodeShapeV2(
                familyId, familyName, minCPU,
                minGPU, minMemoryMB, name,
                nodeShapeId);
        }

    }
}
