/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package dev.hathora.cloud_sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import dev.hathora.cloud_sdk.utils.Utils;
import java.lang.Integer;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;


public class ProcessV3 {

    @JsonProperty("additionalExposedPorts")
    private List<ExposedPort> additionalExposedPorts;

    /**
     * System generated unique identifier for an application.
     */
    @JsonProperty("appId")
    private String appId;

    /**
     * When the container was fully downloaded and started booting.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("bootedAt")
    private Optional<OffsetDateTime> bootedAt;

    /**
     * When the process started being provisioned.
     */
    @JsonProperty("createdAt")
    private OffsetDateTime createdAt;

    /**
     * System generated id for a deployment.
     */
    @JsonProperty("deploymentId")
    private String deploymentId;


    @JsonInclude(Include.ALWAYS)
    @JsonProperty("exposedPort")
    private Optional<? extends ProcessV3ExposedPort> exposedPort;

    /**
     * The id of the fleet.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fleetId")
    private Optional<String> fleetId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hosting")
    private Optional<? extends Hosting> hosting;

    /**
     * System generated unique identifier to a runtime instance of your game server.
     */
    @JsonProperty("processId")
    private String processId;


    @JsonProperty("region")
    private Region region;

    /**
     * Tracks the number of rooms that have been allocated to the process.
     */
    @JsonProperty("roomsAllocated")
    private int roomsAllocated;

    /**
     * Governs how many [rooms](https://hathora.dev/docs/concepts/hathora-entities#room) can be scheduled
     * in a process.
     */
    @JsonProperty("roomsPerProcess")
    private int roomsPerProcess;

    /**
     * When the process was assigned to an available node.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("scheduledAt")
    private Optional<OffsetDateTime> scheduledAt;

    /**
     * When the process bound to the specified port. We use this to determine when to register the process
     * to the load balancer.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("startedAt")
    private Optional<OffsetDateTime> startedAt;


    @JsonProperty("status")
    private ProcessStatus status;

    /**
     * When the process is issued to stop.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("stoppingAt")
    private Optional<OffsetDateTime> stoppingAt;

    /**
     * The summary of why the process exited, if it has stopped.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("summaryExitReason")
    private Optional<String> summaryExitReason;

    /**
     * When the process has been terminated.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("terminatedAt")
    private Optional<OffsetDateTime> terminatedAt;

    @JsonCreator
    public ProcessV3(
            @JsonProperty("additionalExposedPorts") List<ExposedPort> additionalExposedPorts,
            @JsonProperty("appId") String appId,
            @JsonProperty("bootedAt") Optional<OffsetDateTime> bootedAt,
            @JsonProperty("createdAt") OffsetDateTime createdAt,
            @JsonProperty("deploymentId") String deploymentId,
            @JsonProperty("exposedPort") Optional<? extends ProcessV3ExposedPort> exposedPort,
            @JsonProperty("fleetId") Optional<String> fleetId,
            @JsonProperty("hosting") Optional<? extends Hosting> hosting,
            @JsonProperty("processId") String processId,
            @JsonProperty("region") Region region,
            @JsonProperty("roomsAllocated") int roomsAllocated,
            @JsonProperty("roomsPerProcess") int roomsPerProcess,
            @JsonProperty("scheduledAt") Optional<OffsetDateTime> scheduledAt,
            @JsonProperty("startedAt") Optional<OffsetDateTime> startedAt,
            @JsonProperty("status") ProcessStatus status,
            @JsonProperty("stoppingAt") Optional<OffsetDateTime> stoppingAt,
            @JsonProperty("summaryExitReason") Optional<String> summaryExitReason,
            @JsonProperty("terminatedAt") Optional<OffsetDateTime> terminatedAt) {
        Utils.checkNotNull(additionalExposedPorts, "additionalExposedPorts");
        Utils.checkNotNull(appId, "appId");
        Utils.checkNotNull(bootedAt, "bootedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(deploymentId, "deploymentId");
        Utils.checkNotNull(exposedPort, "exposedPort");
        Utils.checkNotNull(fleetId, "fleetId");
        Utils.checkNotNull(hosting, "hosting");
        Utils.checkNotNull(processId, "processId");
        Utils.checkNotNull(region, "region");
        Utils.checkNotNull(roomsAllocated, "roomsAllocated");
        Utils.checkNotNull(roomsPerProcess, "roomsPerProcess");
        Utils.checkNotNull(scheduledAt, "scheduledAt");
        Utils.checkNotNull(startedAt, "startedAt");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(stoppingAt, "stoppingAt");
        Utils.checkNotNull(summaryExitReason, "summaryExitReason");
        Utils.checkNotNull(terminatedAt, "terminatedAt");
        this.additionalExposedPorts = additionalExposedPorts;
        this.appId = appId;
        this.bootedAt = bootedAt;
        this.createdAt = createdAt;
        this.deploymentId = deploymentId;
        this.exposedPort = exposedPort;
        this.fleetId = fleetId;
        this.hosting = hosting;
        this.processId = processId;
        this.region = region;
        this.roomsAllocated = roomsAllocated;
        this.roomsPerProcess = roomsPerProcess;
        this.scheduledAt = scheduledAt;
        this.startedAt = startedAt;
        this.status = status;
        this.stoppingAt = stoppingAt;
        this.summaryExitReason = summaryExitReason;
        this.terminatedAt = terminatedAt;
    }
    
    public ProcessV3(
            List<ExposedPort> additionalExposedPorts,
            String appId,
            OffsetDateTime createdAt,
            String deploymentId,
            String processId,
            Region region,
            int roomsAllocated,
            int roomsPerProcess,
            ProcessStatus status) {
        this(additionalExposedPorts, appId, Optional.empty(),
            createdAt, deploymentId, Optional.empty(),
            Optional.empty(), Optional.empty(), processId,
            region, roomsAllocated, roomsPerProcess,
            Optional.empty(), Optional.empty(), status,
            Optional.empty(), Optional.empty(), Optional.empty());
    }

    @JsonIgnore
    public List<ExposedPort> additionalExposedPorts() {
        return additionalExposedPorts;
    }

    /**
     * System generated unique identifier for an application.
     */
    @JsonIgnore
    public String appId() {
        return appId;
    }

    /**
     * When the container was fully downloaded and started booting.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> bootedAt() {
        return bootedAt;
    }

    /**
     * When the process started being provisioned.
     */
    @JsonIgnore
    public OffsetDateTime createdAt() {
        return createdAt;
    }

    /**
     * System generated id for a deployment.
     */
    @JsonIgnore
    public String deploymentId() {
        return deploymentId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ProcessV3ExposedPort> exposedPort() {
        return (Optional<ProcessV3ExposedPort>) exposedPort;
    }

    /**
     * The id of the fleet.
     */
    @JsonIgnore
    public Optional<String> fleetId() {
        return fleetId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Hosting> hosting() {
        return (Optional<Hosting>) hosting;
    }

    /**
     * System generated unique identifier to a runtime instance of your game server.
     */
    @JsonIgnore
    public String processId() {
        return processId;
    }

    @JsonIgnore
    public Region region() {
        return region;
    }

    /**
     * Tracks the number of rooms that have been allocated to the process.
     */
    @JsonIgnore
    public int roomsAllocated() {
        return roomsAllocated;
    }

    /**
     * Governs how many [rooms](https://hathora.dev/docs/concepts/hathora-entities#room) can be scheduled
     * in a process.
     */
    @JsonIgnore
    public int roomsPerProcess() {
        return roomsPerProcess;
    }

    /**
     * When the process was assigned to an available node.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> scheduledAt() {
        return scheduledAt;
    }

    /**
     * When the process bound to the specified port. We use this to determine when to register the process
     * to the load balancer.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> startedAt() {
        return startedAt;
    }

    @JsonIgnore
    public ProcessStatus status() {
        return status;
    }

    /**
     * When the process is issued to stop.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> stoppingAt() {
        return stoppingAt;
    }

    /**
     * The summary of why the process exited, if it has stopped.
     */
    @JsonIgnore
    public Optional<String> summaryExitReason() {
        return summaryExitReason;
    }

    /**
     * When the process has been terminated.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> terminatedAt() {
        return terminatedAt;
    }

    public static Builder builder() {
        return new Builder();
    }


    public ProcessV3 withAdditionalExposedPorts(List<ExposedPort> additionalExposedPorts) {
        Utils.checkNotNull(additionalExposedPorts, "additionalExposedPorts");
        this.additionalExposedPorts = additionalExposedPorts;
        return this;
    }

    /**
     * System generated unique identifier for an application.
     */
    public ProcessV3 withAppId(String appId) {
        Utils.checkNotNull(appId, "appId");
        this.appId = appId;
        return this;
    }

    /**
     * When the container was fully downloaded and started booting.
     */
    public ProcessV3 withBootedAt(OffsetDateTime bootedAt) {
        Utils.checkNotNull(bootedAt, "bootedAt");
        this.bootedAt = Optional.ofNullable(bootedAt);
        return this;
    }


    /**
     * When the container was fully downloaded and started booting.
     */
    public ProcessV3 withBootedAt(Optional<OffsetDateTime> bootedAt) {
        Utils.checkNotNull(bootedAt, "bootedAt");
        this.bootedAt = bootedAt;
        return this;
    }

    /**
     * When the process started being provisioned.
     */
    public ProcessV3 withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * System generated id for a deployment.
     */
    public ProcessV3 withDeploymentId(String deploymentId) {
        Utils.checkNotNull(deploymentId, "deploymentId");
        this.deploymentId = deploymentId;
        return this;
    }

    public ProcessV3 withExposedPort(ProcessV3ExposedPort exposedPort) {
        Utils.checkNotNull(exposedPort, "exposedPort");
        this.exposedPort = Optional.ofNullable(exposedPort);
        return this;
    }


    public ProcessV3 withExposedPort(Optional<? extends ProcessV3ExposedPort> exposedPort) {
        Utils.checkNotNull(exposedPort, "exposedPort");
        this.exposedPort = exposedPort;
        return this;
    }

    /**
     * The id of the fleet.
     */
    public ProcessV3 withFleetId(String fleetId) {
        Utils.checkNotNull(fleetId, "fleetId");
        this.fleetId = Optional.ofNullable(fleetId);
        return this;
    }


    /**
     * The id of the fleet.
     */
    public ProcessV3 withFleetId(Optional<String> fleetId) {
        Utils.checkNotNull(fleetId, "fleetId");
        this.fleetId = fleetId;
        return this;
    }

    public ProcessV3 withHosting(Hosting hosting) {
        Utils.checkNotNull(hosting, "hosting");
        this.hosting = Optional.ofNullable(hosting);
        return this;
    }


    public ProcessV3 withHosting(Optional<? extends Hosting> hosting) {
        Utils.checkNotNull(hosting, "hosting");
        this.hosting = hosting;
        return this;
    }

    /**
     * System generated unique identifier to a runtime instance of your game server.
     */
    public ProcessV3 withProcessId(String processId) {
        Utils.checkNotNull(processId, "processId");
        this.processId = processId;
        return this;
    }

    public ProcessV3 withRegion(Region region) {
        Utils.checkNotNull(region, "region");
        this.region = region;
        return this;
    }

    /**
     * Tracks the number of rooms that have been allocated to the process.
     */
    public ProcessV3 withRoomsAllocated(int roomsAllocated) {
        Utils.checkNotNull(roomsAllocated, "roomsAllocated");
        this.roomsAllocated = roomsAllocated;
        return this;
    }

    /**
     * Governs how many [rooms](https://hathora.dev/docs/concepts/hathora-entities#room) can be scheduled
     * in a process.
     */
    public ProcessV3 withRoomsPerProcess(int roomsPerProcess) {
        Utils.checkNotNull(roomsPerProcess, "roomsPerProcess");
        this.roomsPerProcess = roomsPerProcess;
        return this;
    }

    /**
     * When the process was assigned to an available node.
     */
    public ProcessV3 withScheduledAt(OffsetDateTime scheduledAt) {
        Utils.checkNotNull(scheduledAt, "scheduledAt");
        this.scheduledAt = Optional.ofNullable(scheduledAt);
        return this;
    }


    /**
     * When the process was assigned to an available node.
     */
    public ProcessV3 withScheduledAt(Optional<OffsetDateTime> scheduledAt) {
        Utils.checkNotNull(scheduledAt, "scheduledAt");
        this.scheduledAt = scheduledAt;
        return this;
    }

    /**
     * When the process bound to the specified port. We use this to determine when to register the process
     * to the load balancer.
     */
    public ProcessV3 withStartedAt(OffsetDateTime startedAt) {
        Utils.checkNotNull(startedAt, "startedAt");
        this.startedAt = Optional.ofNullable(startedAt);
        return this;
    }


    /**
     * When the process bound to the specified port. We use this to determine when to register the process
     * to the load balancer.
     */
    public ProcessV3 withStartedAt(Optional<OffsetDateTime> startedAt) {
        Utils.checkNotNull(startedAt, "startedAt");
        this.startedAt = startedAt;
        return this;
    }

    public ProcessV3 withStatus(ProcessStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * When the process is issued to stop.
     */
    public ProcessV3 withStoppingAt(OffsetDateTime stoppingAt) {
        Utils.checkNotNull(stoppingAt, "stoppingAt");
        this.stoppingAt = Optional.ofNullable(stoppingAt);
        return this;
    }


    /**
     * When the process is issued to stop.
     */
    public ProcessV3 withStoppingAt(Optional<OffsetDateTime> stoppingAt) {
        Utils.checkNotNull(stoppingAt, "stoppingAt");
        this.stoppingAt = stoppingAt;
        return this;
    }

    /**
     * The summary of why the process exited, if it has stopped.
     */
    public ProcessV3 withSummaryExitReason(String summaryExitReason) {
        Utils.checkNotNull(summaryExitReason, "summaryExitReason");
        this.summaryExitReason = Optional.ofNullable(summaryExitReason);
        return this;
    }


    /**
     * The summary of why the process exited, if it has stopped.
     */
    public ProcessV3 withSummaryExitReason(Optional<String> summaryExitReason) {
        Utils.checkNotNull(summaryExitReason, "summaryExitReason");
        this.summaryExitReason = summaryExitReason;
        return this;
    }

    /**
     * When the process has been terminated.
     */
    public ProcessV3 withTerminatedAt(OffsetDateTime terminatedAt) {
        Utils.checkNotNull(terminatedAt, "terminatedAt");
        this.terminatedAt = Optional.ofNullable(terminatedAt);
        return this;
    }


    /**
     * When the process has been terminated.
     */
    public ProcessV3 withTerminatedAt(Optional<OffsetDateTime> terminatedAt) {
        Utils.checkNotNull(terminatedAt, "terminatedAt");
        this.terminatedAt = terminatedAt;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ProcessV3 other = (ProcessV3) o;
        return 
            Utils.enhancedDeepEquals(this.additionalExposedPorts, other.additionalExposedPorts) &&
            Utils.enhancedDeepEquals(this.appId, other.appId) &&
            Utils.enhancedDeepEquals(this.bootedAt, other.bootedAt) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.deploymentId, other.deploymentId) &&
            Utils.enhancedDeepEquals(this.exposedPort, other.exposedPort) &&
            Utils.enhancedDeepEquals(this.fleetId, other.fleetId) &&
            Utils.enhancedDeepEquals(this.hosting, other.hosting) &&
            Utils.enhancedDeepEquals(this.processId, other.processId) &&
            Utils.enhancedDeepEquals(this.region, other.region) &&
            Utils.enhancedDeepEquals(this.roomsAllocated, other.roomsAllocated) &&
            Utils.enhancedDeepEquals(this.roomsPerProcess, other.roomsPerProcess) &&
            Utils.enhancedDeepEquals(this.scheduledAt, other.scheduledAt) &&
            Utils.enhancedDeepEquals(this.startedAt, other.startedAt) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.stoppingAt, other.stoppingAt) &&
            Utils.enhancedDeepEquals(this.summaryExitReason, other.summaryExitReason) &&
            Utils.enhancedDeepEquals(this.terminatedAt, other.terminatedAt);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            additionalExposedPorts, appId, bootedAt,
            createdAt, deploymentId, exposedPort,
            fleetId, hosting, processId,
            region, roomsAllocated, roomsPerProcess,
            scheduledAt, startedAt, status,
            stoppingAt, summaryExitReason, terminatedAt);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ProcessV3.class,
                "additionalExposedPorts", additionalExposedPorts,
                "appId", appId,
                "bootedAt", bootedAt,
                "createdAt", createdAt,
                "deploymentId", deploymentId,
                "exposedPort", exposedPort,
                "fleetId", fleetId,
                "hosting", hosting,
                "processId", processId,
                "region", region,
                "roomsAllocated", roomsAllocated,
                "roomsPerProcess", roomsPerProcess,
                "scheduledAt", scheduledAt,
                "startedAt", startedAt,
                "status", status,
                "stoppingAt", stoppingAt,
                "summaryExitReason", summaryExitReason,
                "terminatedAt", terminatedAt);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private List<ExposedPort> additionalExposedPorts;

        private String appId;

        private Optional<OffsetDateTime> bootedAt = Optional.empty();

        private OffsetDateTime createdAt;

        private String deploymentId;

        private Optional<? extends ProcessV3ExposedPort> exposedPort = Optional.empty();

        private Optional<String> fleetId = Optional.empty();

        private Optional<? extends Hosting> hosting = Optional.empty();

        private String processId;

        private Region region;

        private Integer roomsAllocated;

        private Integer roomsPerProcess;

        private Optional<OffsetDateTime> scheduledAt = Optional.empty();

        private Optional<OffsetDateTime> startedAt = Optional.empty();

        private ProcessStatus status;

        private Optional<OffsetDateTime> stoppingAt = Optional.empty();

        private Optional<String> summaryExitReason = Optional.empty();

        private Optional<OffsetDateTime> terminatedAt = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        public Builder additionalExposedPorts(List<ExposedPort> additionalExposedPorts) {
            Utils.checkNotNull(additionalExposedPorts, "additionalExposedPorts");
            this.additionalExposedPorts = additionalExposedPorts;
            return this;
        }


        /**
         * System generated unique identifier for an application.
         */
        public Builder appId(String appId) {
            Utils.checkNotNull(appId, "appId");
            this.appId = appId;
            return this;
        }


        /**
         * When the container was fully downloaded and started booting.
         */
        public Builder bootedAt(OffsetDateTime bootedAt) {
            Utils.checkNotNull(bootedAt, "bootedAt");
            this.bootedAt = Optional.ofNullable(bootedAt);
            return this;
        }

        /**
         * When the container was fully downloaded and started booting.
         */
        public Builder bootedAt(Optional<OffsetDateTime> bootedAt) {
            Utils.checkNotNull(bootedAt, "bootedAt");
            this.bootedAt = bootedAt;
            return this;
        }


        /**
         * When the process started being provisioned.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * System generated id for a deployment.
         */
        public Builder deploymentId(String deploymentId) {
            Utils.checkNotNull(deploymentId, "deploymentId");
            this.deploymentId = deploymentId;
            return this;
        }


        public Builder exposedPort(ProcessV3ExposedPort exposedPort) {
            Utils.checkNotNull(exposedPort, "exposedPort");
            this.exposedPort = Optional.ofNullable(exposedPort);
            return this;
        }

        public Builder exposedPort(Optional<? extends ProcessV3ExposedPort> exposedPort) {
            Utils.checkNotNull(exposedPort, "exposedPort");
            this.exposedPort = exposedPort;
            return this;
        }


        /**
         * The id of the fleet.
         */
        public Builder fleetId(String fleetId) {
            Utils.checkNotNull(fleetId, "fleetId");
            this.fleetId = Optional.ofNullable(fleetId);
            return this;
        }

        /**
         * The id of the fleet.
         */
        public Builder fleetId(Optional<String> fleetId) {
            Utils.checkNotNull(fleetId, "fleetId");
            this.fleetId = fleetId;
            return this;
        }


        public Builder hosting(Hosting hosting) {
            Utils.checkNotNull(hosting, "hosting");
            this.hosting = Optional.ofNullable(hosting);
            return this;
        }

        public Builder hosting(Optional<? extends Hosting> hosting) {
            Utils.checkNotNull(hosting, "hosting");
            this.hosting = hosting;
            return this;
        }


        /**
         * System generated unique identifier to a runtime instance of your game server.
         */
        public Builder processId(String processId) {
            Utils.checkNotNull(processId, "processId");
            this.processId = processId;
            return this;
        }


        public Builder region(Region region) {
            Utils.checkNotNull(region, "region");
            this.region = region;
            return this;
        }


        /**
         * Tracks the number of rooms that have been allocated to the process.
         */
        public Builder roomsAllocated(int roomsAllocated) {
            Utils.checkNotNull(roomsAllocated, "roomsAllocated");
            this.roomsAllocated = roomsAllocated;
            return this;
        }


        /**
         * Governs how many [rooms](https://hathora.dev/docs/concepts/hathora-entities#room) can be scheduled
         * in a process.
         */
        public Builder roomsPerProcess(int roomsPerProcess) {
            Utils.checkNotNull(roomsPerProcess, "roomsPerProcess");
            this.roomsPerProcess = roomsPerProcess;
            return this;
        }


        /**
         * When the process was assigned to an available node.
         */
        public Builder scheduledAt(OffsetDateTime scheduledAt) {
            Utils.checkNotNull(scheduledAt, "scheduledAt");
            this.scheduledAt = Optional.ofNullable(scheduledAt);
            return this;
        }

        /**
         * When the process was assigned to an available node.
         */
        public Builder scheduledAt(Optional<OffsetDateTime> scheduledAt) {
            Utils.checkNotNull(scheduledAt, "scheduledAt");
            this.scheduledAt = scheduledAt;
            return this;
        }


        /**
         * When the process bound to the specified port. We use this to determine when to register the process
         * to the load balancer.
         */
        public Builder startedAt(OffsetDateTime startedAt) {
            Utils.checkNotNull(startedAt, "startedAt");
            this.startedAt = Optional.ofNullable(startedAt);
            return this;
        }

        /**
         * When the process bound to the specified port. We use this to determine when to register the process
         * to the load balancer.
         */
        public Builder startedAt(Optional<OffsetDateTime> startedAt) {
            Utils.checkNotNull(startedAt, "startedAt");
            this.startedAt = startedAt;
            return this;
        }


        public Builder status(ProcessStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * When the process is issued to stop.
         */
        public Builder stoppingAt(OffsetDateTime stoppingAt) {
            Utils.checkNotNull(stoppingAt, "stoppingAt");
            this.stoppingAt = Optional.ofNullable(stoppingAt);
            return this;
        }

        /**
         * When the process is issued to stop.
         */
        public Builder stoppingAt(Optional<OffsetDateTime> stoppingAt) {
            Utils.checkNotNull(stoppingAt, "stoppingAt");
            this.stoppingAt = stoppingAt;
            return this;
        }


        /**
         * The summary of why the process exited, if it has stopped.
         */
        public Builder summaryExitReason(String summaryExitReason) {
            Utils.checkNotNull(summaryExitReason, "summaryExitReason");
            this.summaryExitReason = Optional.ofNullable(summaryExitReason);
            return this;
        }

        /**
         * The summary of why the process exited, if it has stopped.
         */
        public Builder summaryExitReason(Optional<String> summaryExitReason) {
            Utils.checkNotNull(summaryExitReason, "summaryExitReason");
            this.summaryExitReason = summaryExitReason;
            return this;
        }


        /**
         * When the process has been terminated.
         */
        public Builder terminatedAt(OffsetDateTime terminatedAt) {
            Utils.checkNotNull(terminatedAt, "terminatedAt");
            this.terminatedAt = Optional.ofNullable(terminatedAt);
            return this;
        }

        /**
         * When the process has been terminated.
         */
        public Builder terminatedAt(Optional<OffsetDateTime> terminatedAt) {
            Utils.checkNotNull(terminatedAt, "terminatedAt");
            this.terminatedAt = terminatedAt;
            return this;
        }

        public ProcessV3 build() {

            return new ProcessV3(
                additionalExposedPorts, appId, bootedAt,
                createdAt, deploymentId, exposedPort,
                fleetId, hosting, processId,
                region, roomsAllocated, roomsPerProcess,
                scheduledAt, startedAt, status,
                stoppingAt, summaryExitReason, terminatedAt);
        }

    }
}
